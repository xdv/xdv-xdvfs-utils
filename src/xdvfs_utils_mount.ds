// File: xdvfs_utils_mount.ds - This file is part of XDV
// Copyright (c) 2026 Dust LLC, and Contributors
// Description:
//   xdv-xdvfs-utils: mount workflows
//   DPL implementation of mount/umount/remount/sync operations.

forge XdvFsUtilsMount {

    const STATUS_OK: UInt32 = 0;
    const STATUS_MOUNT_FAILED: UInt32 = 1;
    const STATUS_SYNC_FAILED: UInt32 = 2;

    const MOUNT_FLAGS_DEFAULT: UInt32 = 0;
    const MOUNT_FLAGS_RDONLY: UInt32 = 1;
    const MOUNT_FLAGS_SYNC: UInt32 = 16;

    const DEFAULT_DEVICE_HANDLE: UInt64 = 1;

    proc K::mount_xdvfs(device: Str, mount_point: Str) {
        emit "xdvfs-utils: mount start";
        let status = mount(device, mount_point, "xdvfs", MOUNT_FLAGS_DEFAULT);
        if status == STATUS_OK {
            return STATUS_OK;
        } else {
            return STATUS_MOUNT_FAILED;
        }
    }

    proc K::mount_read_only(device: Str, mount_point: Str) {
        emit "xdvfs-utils: mount read-only";
        let status = mount(device, mount_point, "xdvfs", MOUNT_FLAGS_RDONLY);
        if status == STATUS_OK {
            return STATUS_OK;
        } else {
            return STATUS_MOUNT_FAILED;
        }
    }

    proc K::mount_remount(mount_point: Str, flags: UInt32) {
        emit "xdvfs-utils: remount";
        let status = remount(mount_point, flags);
        if status == STATUS_OK {
            return STATUS_OK;
        } else {
            return STATUS_MOUNT_FAILED;
        }
    }

    proc K::mount_sync(mount_point: Str) {
        emit "xdvfs-utils: sync";
        let sync_status = sync_filesystem(DEFAULT_DEVICE_HANDLE);
        if sync_status == STATUS_OK {
            let remount_status = remount(mount_point, MOUNT_FLAGS_SYNC);
            if remount_status == STATUS_OK {
                return STATUS_OK;
            } else {
                return STATUS_MOUNT_FAILED;
            }
        } else {
            return STATUS_SYNC_FAILED;
        }
    }

    proc K::mount_umount(mount_point: Str) {
        emit "xdvfs-utils: umount";
        let status = unmount(mount_point);
        if status == STATUS_OK {
            return STATUS_OK;
        } else {
            return STATUS_MOUNT_FAILED;
        }
    }

    proc K::mount_check(device: Str) {
        emit "xdvfs-utils: mount check";
        let status = check_filesystem(device);
        if status == STATUS_OK {
            return STATUS_OK;
        } else {
            return STATUS_MOUNT_FAILED;
        }
    }
}
